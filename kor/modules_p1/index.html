<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Park DongHa <luncliff@gmail.com>">
  <link rel="canonical" href="https://luncliff.github.io/modern-cpp-next/kor/modules_p1/">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Part 1 - Modern C++ Next</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Part 1";
    var mkdocs_page_input_path = "kor/modules_p1.md";
    var mkdocs_page_url = "/modern-cpp-next/kor/modules_p1/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c++.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Modern C++ Next</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../getting_started/">Getting Started</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Modules</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../modules_p0/">Overview</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Part 1</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">준비</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">현재의 컴파일 과정</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#warming-up">워밍업 (Warming up)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#preprocessing">전처리 (Preprocessing)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">전처리의 양면성</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_4">밝은 부분</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_5">어두운 부분</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#modules">Modules의 접근법</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#module-interface-unit">Module Interface Unit</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#module">Module 구현</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#module_1">Module 사용</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">정리</a>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Modern C++ Next</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Modules &raquo;</li>
        
      
    
    <li>Part 1</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="http://github.com/luncliff/modern-cpp-next/edit/master/docs/kor/modules_p1.md"> Edit on luncliff/modern-cpp-next</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="c-modules-with-clang">C++ Modules with Clang</h1>
<p>아직 C++ Modules의 모든 내용을 시험해볼 수 있는 것은 아니지만, 대략적인 내용을 확인하는 것은 어렵지 않습니다.
다른 내용에 앞서 Modules를 사용하게 되면 컴파일 과정이 어떻게 바뀌는지를 Clang 컴파일러로 확인해보겠습니다.</p>
<h3 id="_1">준비</h3>
<ul>
<li>Clang 컴파일러 (LLVM 9.0+, AppleClang 11.0+)</li>
<li><a href="https://www.gnu.org/software/make/manual/make.html">GNU Make</a>: http://wiki.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make.html</li>
</ul>
<h2 id="_2">현재의 컴파일 과정</h2>
<h3 id="warming-up">워밍업 (Warming up)</h3>
<p>지금 설명하는 주제에 관심이 있는 분이라면 이미 알고 계시겠지만, 컴파일 언어인 C++에서 프로그램은 1개 이상의 소스코드 파일로 구성됩니다.
소스 코드란, 아래와 같이 C++ 문법에 맞춰 작성한 텍스트를 가리키는 것이구요.</p>
<pre><code class="c++">/// @file examples/modules_p1_1.cpp
#include &lt;cstdio&gt;

int main(int argc, char* argv[]){
    for(auto i = 0; i &lt; argc; ++i)
        fputs(argv[i], stdout);
    return 0;
}
</code></pre>

<pre><code class="bash">clang -std=c++2a ./modules_p0_1.cpp
</code></pre>

<p>위와 같이 컴파일러를 호출해서 프로그램을 만들 수 있습니다.
전통에 따라 a.out파일이 만들어질텐데요.
프로그램이란 (천공카드처럼) 일련의 비트이긴 하지만, 소스코드의 의미을 반영하여 Text와 Data로 그 영역이 구분되어 있습니다.</p>
<pre><code class="console">user@host:~/examples $ objdump -syms ./a.out 

./a.out:        file format Mach-O 64-bit x86-64

SYMBOL TABLE:
0000000100002008 l     O __DATA,__data  __dyld_private
0000000100000000 g     F __TEXT,__text  __mh_execute_header
0000000100000f30 g     F __TEXT,__text  _main
0000000000000000         *UND*  ___stdoutp
0000000000000000         *UND*  _fputs
0000000000000000         *UND*  dyld_stub_binder
</code></pre>

<p>출력 내용을 보면 <code>a.out</code>만으로는 알 수 없는 부분도 있지만, 소스코드에 있었던 <code>main</code>, <code>fputs</code>, <code>stdout</code>이 모두 나타난 것을 볼 수 있습니다. (이름이 약간 다른 것 같지만 개의치 마세요!)
컴파일러가 프로그래머의 의도를 (아마도) 잘 해석했다는 것을 짐작할 수 있는 부분입니다.</p>
<p>방금 사용한 <code>-syms</code>옵션의 이름처럼, 프로그램은 비트로 만들어져있고, 비트 묶음에는 부호(symbol, 어떠한 뜻을 나타내기 위하여 정한 기호)가 부여됩니다. 부호에 담긴 의미로는 TEXT, DATA 등등이 있는 것이죠.</p>
<p>그리고 컴파일러가 그 부호를 만들기 위해 필요로 하는 것이 바로 선언(Declaration)입니다.
C++ 코드를 구성하는 것 중 가장 많은 부분을 차지하는 부분이죠...</p>
<h3 id="preprocessing">전처리 (Preprocessing)</h3>
<p>그런데 소스코드마다 필요한 선언들을 작성하고, 이들의 정합(consistency)을 유지해주는 것은 상당히 번거롭기 때문에, 전처리기(Preprocessor)가 사용됩니다.
<code>#include</code>와 같은 지시(directive)를 써서 파일의 내용을 복사-붙여넣기 한다거나, <code>#define</code>을 써서 특정 문자열을 치환하는 일을 합니다.</p>
<p>좀 전의 코드가 전처리기를 거치면 어떻게 되는지 바로 확인해보도록 하죠. (<code>-E</code> 옵션)
전처리기의 동작만 확인할 목적으로 파일을 만들기엔 번거로우니 Pipe를 써서(<code>|</code>) 표준 입력으로 소스코드를 제공해보겠습니다. (<code>-</code> 옵션)
좀 더 친절하게, 무슨 프로그래밍 언어인지도 알려주도록 하죠. (<code>-x c++</code> 옵션)</p>
<p>제 기억에 libc++에서 가장 간단한 헤더는 <code>&lt;__nullptr&gt;</code>였던 것 같습니다.</p>
<pre><code>user@host:~/examples $ echo &quot;#include &lt;__nullptr&gt;&quot; | clang -x c++ -E -
# 1 &quot;&lt;stdin&gt;&quot;
...
# 18 &quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__nullptr&quot; 3

namespace std { inline namespace __1 {

struct __attribute__ ((__type_visibility__(&quot;default&quot;))) nullptr_t
{
    void* __lx;
    // ...
};

inline __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}

} }
# 2 &quot;&lt;stdin&gt;&quot; 2
</code></pre>

<p><code>std::nullptr_t</code>가 사실은 <code>struct</code>라는 것을 알게된 기쁨(?)은 제쳐두고, 전처리기가 코드를 잘 정리해서 하나의 소스파일로 만들어준다는 것을 알 수 있었습니다.
C++ 에서는 위처럼 <strong>전처리를 거친 소스파일을 Translation Unit이라 합니다</strong>. (편의상 이후로는 TU라고 하겠습니다.)
즉, 이때부터 소스코드가 컴파일(Translation)이 되어 이진(binary) 형태로 바뀌는 것이죠.</p>
<ul>
<li>함께 보기: C++ Standard: 5. Lexical Conventions</li>
</ul>
<h3 id="_3">전처리의 양면성</h3>
<h4 id="_4">밝은 부분</h4>
<p>전처리기를 사용해서 얻는 장점은 명확합니다. </p>
<ul>
<li>소스코드 재작성을 자동화: 선언을 모아놓은 파일(header)의 내용을 복사하도록 함으로써 다시 작성해줄 필요가 없음</li>
<li>일률적임: header 파일은 일반적인 소스파일처럼 관리가 가능</li>
<li>제어가 가능함: 소스파일을 변경하지 않으면서 TU를 변경할 수 있음(부분적인 활성화/비활성화 등)</li>
</ul>
<p>헤더 파일을 사용하기 위해선 해당 파일을 찾기 위한 경로를 제공해야 하지만, <code>/usr/include</code>와 같이 묵시적으로 사용되는 경로라면 생략이 가능합니다. 컴파일러를 위한 복잡한 옵션이 필요하진 않은 것이죠.
무엇보다 소스파일 내에서서 읽을 수 있는 형태로 드러나기 때문에 프로그래머에게 주는 전달력 또한 상당하다는 점을 들 수 있습니다.</p>
<p>예컨대, 아래의 코드는 별다른 설명 없이도 그 내용을 짐작할 수 있습니다.
그 내용이란, 이 소스파일이 <code>openssl</code>이라는 라이브러리의 선언을 사용하며, 선언 중에 <code>SHA_CTX</code>, <code>SHA1_Init</code>등의 존재를 확인할 수 있다는 의미입니다.</p>
<pre><code class="c++">#include &lt;cstddef&gt;  // C++17 byte
#include &lt;array&gt;    // C++11 array

#include &lt;openssl/sha.h&gt;

using namespace std;

int digest_sha1(FILE* fin, 
                array&lt;byte, SHA_DIGEST_LENGTH&gt;&amp; digest){
    SHA_CTX ctx{};
    SHA1_Init(&amp;ctx);

    auto&amp; buffer = digest; // alias for readability
    while(auto count = fread(buffer.data(), buffer.size(), fin))
        SHA1_Update(&amp;ctx, buffer.data(), count);

    return SHA1_Final(digest.data(), &amp;ctx);
}
</code></pre>

<h4 id="_5">어두운 부분</h4>
<p>하지만 모든 프로그램이 위와 같이 단순하지는 않습니다. 어려움이 발생하는 근본적인 원인으로 2가지를 들 수 있는데,
첫째는 대부분의 프로젝트는 수많은 파일을 사용해 상당한 수의 TU를 생성한다는 것입니다.</p>
<p>...<br />
결과적으로 소스코드의 양이 늘어나기 때문에 전체 컴파일 시간(즉, 빌드 시간)은 길어지게 될 것입니다.</p>
<p>두번째는 이 TU들의 컴파일 시점이 다를 수 있다는 것입니다.
다음과 같은 상황이 발생한다면 어떨까요?</p>
<ol>
<li>라이브러리를 개발할 때 의도한 헤더들의 include 순서는 A-B-C 였는데,<br />
  이를 사용하는 코드에서는 B-A-C 순서로 include 하도록 헤더를 수정하였다.</li>
<li>A 헤더에서 <code>#ifdef</code> 조건을 사용하고 있었는데,<br />
  새로 B 헤더가 그 앞에 include 되면서 조건이 반전되었다 (false 였다면 true로 변함. 혹은 그 반대)</li>
</ol>
<p>위 두 상황이 시사하는 점은, 선언을 모아놓은 헤더 파일은 <strong>변경될 수 있으며(mutable)</strong>, 이것이 전처리기와 같이 <strong>헤더파일에서 제어할 수 없는 요인에 의해 발생할 수 있다</strong>는 것입니다.</p>
<p>전처리기의 장점을 되짚어보면 C++ 프로젝트의 규모가 커지고 의존성이 복잡해질 수록 이같은 문제로 인한 위험이 더 커진다는 것을 예상할 수 있습니다.
물론 오늘날 많은 C++ 라이브러리들은 이 문제를 위한 최소한의 방어법을 적용하고 있습니다.</p>
<p>매크로를 <code>constexpr</code> 혹은 <code>if constexpr</code>로 대체하면서 전처리기 의존을 낮추고, 사용하게 되더라도 매크로 조건이 충돌하거나 의도한 범위를 넘어서 영향을 주지않도록(<code>#undef</code>) 설계하며, 미리 정해진 순서로 부분 헤더파일을 include하는 헤더파일을 제공하기도 합니다. 
하지만 전처리기에 의존하는 이상 이런 문제들은 계속 발생할 수 밖에 없기 때문에 복잡성은 계속 증가하게 됩니다.</p>
<h2 id="modules">Modules의 접근법</h2>
<p>Modules의 접근법은 이렇습니다. <strong>하나의 TU를 미리 컴파일하여, 이로부터 symbol을 얻는다</strong>.<br />
이 방법이 가져오는 효과는 2가지 입니다.</p>
<ol>
<li>소스 파일을 노출하지 않기 때문에 변경이 불가능하다</li>
<li>컴파일을 거치기 때문에 <strong>컴파일 시점의 전처리 결과를 반영한다</strong></li>
</ol>
<p>TU는 전처리기를 거친 것이라고 서두에서 설명드렸던 것을 기억하시나요? 
결국 전처리 과정에서 (주요 선언을 포함한) 소스코드가 변경될 수 있다는 것.
변경이 발생하는 것은 미래 시점이기에 제어할 수 없다는 것이
현재까지의 컴파일 과정에서 문제가 끊이지 않는 원인이라는 것이죠.</p>
<p>선언을 '박제'한다는 점에서 .exp 파일을 떠올리는 분들도 계실 것 같습니다. 구체적인 사용법을 살펴보도록 하죠.</p>
<h3 id="module-interface-unit">Module Interface Unit</h3>
<p>모듈을 만들고 사용하는 것은 먼저 모듈이 노출하는(export) 선언들이 모여있는 하나의 TU를 컴파일하는 것으로 시작합니다.
이를 Module Interface Unit이라고 합니다. </p>
<p>모든 모듈은 오직 하나의 MIU만을 가질 수 있습니다. 
MIU의 작성방법은 굉장히 간단한데, 그저 <code>export module m1;</code>를 선언하면, 그 이후의 내용은 전부 <code>m1</code>에 귀속됩니다. 이를 모듈의 범위(Purview)라고 합니다.</p>
<pre><code class="c++">/// @file examples/modules_p1_2.cpp
/// @see https://en.cppreference.com/w/cpp/preprocessor/replace
#if not defined(__cpp_modules)
#warning &quot;'__cpp_modules' not defined&quot;
#endif
#include &lt;cstdint&gt;
export module m1; // all following declarations will be in `m1`

export struct endpoint_t {
    uint32_t _u32[4];
};

export uint16_t lookup(endpoint_t* base, uint16_t capacity, //
                       const char* hostname,                //
                       const char* servname) noexcept;
</code></pre>

<p>모듈의 다른 소스코드를 컴파일하고, 최종적으로 라이브러리 혹은 실행파일을 만들기 위해선 위와 같은 MIU를 먼저 컴파일(precompile) 해야 합니다.</p>
<p>Clang의 경우, 아래와 같이 수행할 수 있습니다.</p>
<pre><code class="console">user@host:~/examples $ clang -x c++-module -std=c
++2a -fmodules-ts --precompile -o m1.ifc ./modules_p1_2.c
pp 
./modules_p1_2.cpp:4:2: warning: &quot;'__cpp_modules' not
      defined&quot; [-W#warnings]
#warning &quot;'__cpp_modules' not defined&quot;
 ^
1 warning generated.
</code></pre>

<p>Makefile로 작성한다면 이런 형태가 되겠지요.</p>
<pre><code class="makefile">CXXFLAGS    = -std=c++2a -fmodules-ts

m1.ifc: modules_p1_2.cpp
    clang $(CXXFLAGS) -x c++-module \
         --precompile -o m1.ifc $?
</code></pre>

<p><code>.ifc</code> 이라는 확장자는 예약된 것은 아닙니다. 당장은 Precompiled Module을 위한 임의의 확장자가 있다고 생각하시면 되겠습니다.
아마 이 파일의 규격화(즉, 컴파일러 종속적이지 않은 ifc 파일)는 C++ 20 이후 다소 시간이 지난 후에야 이루어질 수 있을 것입니다.</p>
<blockquote>
<p>실제로는 Clang에서는 <code>.cppm</code>이라는 확장자가 사용되고 있습니다.</p>
</blockquote>
<p>현재로써는 이 파일 안에 어떤 symbol이 들어있는지 확인하는 방법이 없습니다. 하지만 실제로 사용해보면 적법한(valid) 내용이 있는지 확인하는 것은 가능합니다.</p>
<ol>
<li>구현 코드(module)를 작성해본다</li>
<li>사용 코드(import)를 작성해본다</li>
</ol>
<h3 id="module">Module 구현</h3>
<p>export의 선언은 MIU에서만 가능하기 때문에, <code>module m1</code>의 구현파일들에서는 따로 export 키워드를 사용할 일은 없습니다. 다만 m1의 범위(Purview)
안에서 구현을 제공하기만 하면 됩니다.</p>
<p>범위를 바꾸는 것은 아래 코드처럼 <code>module m1;</code>를 선언하는 것으로 충분합니다.</p>
<pre><code class="c++">/// @file examples/module_p1_3.cpp
#include &lt;cstdint&gt;
module m1; // `endpoint_t` becomes visible
           // since it's purview of `m1`

uint16_t lookup(endpoint_t* base, uint16_t capacity, //
                const char* hostname,                //
                const char* servname) noexcept {
    return 0;
}
</code></pre>

<p>이 TU에는 <code>endpoint_t</code>에 대한 선언이 없지만, <code>m1</code>의 범위에서는 문제가 되지 않습니다. 이를 Visible 하다고 표현합니다.<br />
특히, 이는 선언(Declaration)에 대한 것이므로, Linking 과정에서 Symbol에 대한 접근을 제어하는 <code>-fvisibility</code>옵션과는 다르다는 점을 숙지할 필요가 있습니다.</p>
<p>컴파일 명령은 일반적인 C++ 소스코드와 유사합니다. 다만, 새로 2개의 옵션을 지정해줄 필요가 있습니다.</p>
<ul>
<li><code>-fprebuilt-module-path</code>: .ifc 파일을 찾기 위한 폴더 지정</li>
<li><code>-fmodule-file</code>: 현재 구현중인 모듈의 .ifc 파일 이름</li>
</ul>
<pre><code class="makefile">CXXFLAGS    = -std=c++2a -fmodules-ts
# ...
m1_impl_1.o: modules_p1_3.cpp
    clang $(CXXFLAGS) \
        -fprebuilt-module-path=/usr/local/include \
        -fprebuilt-module-path=. \
        -fmodule-file=m1.ifc -o m1_impl_1.o -c $?
</code></pre>

<p>명령을 보면 <code>-fprebuilt-module-path</code>는 헤더를 찾을 수 있도록 <code>-I</code>옵션을 제공했던 것과 유사합니다.
컴파일 방법을 알았으니, <code>mi_impl_1.o</code>파일에서 symbol을 확인해볼 수 있겠군요.</p>
<pre><code class="console">~/examples $ make m1_impl_1.o
clang -std=c++2a -fmodules-ts \
        -fprebuilt-module-path=/usr/local/include \
        -fprebuilt-module-path=. \
        -fmodule-file=m1.ifc -o m1_impl_1.o -c modules_p1
_3.cpp
~/examples $ luncliff$ nm --demangle ./m1_impl_1.
o 
0000000000000000 T lookup(endpoint_t*, unsigned short, ch
ar const*, char const*)
</code></pre>

<ul>
<li>Q. <code>-fmodule-file</code>을 생략하고 컴파일 해보세요! (컴파일 옵션)</li>
<li>Q. 소스 코드에서 <code>module m1;</code>을 생략한 뒤에 컴파일 오류를 확인하세요! (purview 이해하기)</li>
<li>Q. 소스 코드에서 <code>module m1;</code>의 위치를 <code>lookup</code>함수의 정의보다 아래쪽에 배치하고 컴파일 오류를 확인하세요! (purview 이해하기)</li>
</ul>
<h3 id="module_1">Module 사용</h3>
<p>앞선 예제로 확인하셨겠지만, 모듈을 사용하기 시작한다고 해서 헤더파일(즉, 전처리기에 의한 <code>#include</code>)를 사용할 수 없게 되는 것은 아닙니다.</p>
<p>다만 컴파일된 모듈 인터페이스가 있다면, import 하는 것이 가능하다는 것이죠.</p>
<pre><code class="c++">/// @file examples/modules_p1_5.cpp
#include &lt;array&gt;
#include &lt;iostream&gt;
import m1;

std::array&lt;endpoint_t, 10&gt; endpoints{};

int main(int, char*[]) {
    auto count = lookup(endpoints.data(), endpoints.size(), //
                        &quot;releases.llvm.org&quot;, &quot;https&quot;);

    std::cout &lt;&lt; count &lt;&lt; std::endl;
    for (auto i = 0u; i &lt; count; ++i) {
        endpoints[i];
    }
    return count &gt; 0 ? EXIT_SUCCESS : EXIT_FAILURE;
}
</code></pre>

<p><a href="https://youtu.be/tjSuKOz5HK4?t=2286">헤더파일들이 지원하기만 한다면, 헤더파일들에도 <code>import</code>가 가능합니다</a>.
<code>#include</code>가 코드의 복제인데 반해, <code>import</code>는 헤더파일 안에 있는 코드를 한번 처리하여, 그 중간결과물을 다른 TU의 import에서 재사용합니다. 결과적으로 처리 시간이 좀 더 줄어들게 되겠죠. (안타깝게도 아직은 지원되지 않습니다.)</p>
<pre><code class="c++">import &lt;array&gt;;
import &lt;iostream&gt;;
import m1;
// ...
</code></pre>

<p>앞서 만들어놓은 <code>m1</code>의 구현 object와 함께 빌드하는 것은 아래처럼 할 수 있습니다. (편의상 <code>-fprebuilt-module-path</code>를 생략하였습니다.)</p>
<pre><code class="makefile">LDFLAGS     = -lc++
CXXFLAGS    = -std=c++2a -fmodules-ts
# ...
m1_usage: m1_impl_1.o modules_p1_5.cpp
    clang $(CXXFLAGS) $(LDFLAGS) \
        -fmodule-file=m1.ifc $?
</code></pre>

<pre><code class="console">user@host:~/examples $ make m1_usage
clang -std=c++2a -fmodules-ts -lc++ \
        -fmodule-file=m1.ifc m1_impl_1.o modules_p1_5.cpp
user@host:~/examples $ nm --demangle ./a.out 
0000000100000f6c s GCC_except_table6
                 U __Unwind_Resume
0000000100000bf0 T lookup(endpoint_t*, unsigned short, char const*, 
char const*)
...
0000000100000c20 T _main
...
</code></pre>

<h2 id="_6">정리</h2>
<p>소스 코드 수준의 차이점은 Modules를 적용했다는 것이고, 
빌드 과정에서 달라진 것은 <code>-fmodule-file=m1.ifc</code>와 같이 미리 컴파일된 모듈 인터페이스 파일들을 제공하게 되었다는 것입니다.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../modules_p0/" class="btn btn-neutral" title="Overview"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>MIT</p>
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../modules_p0/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
